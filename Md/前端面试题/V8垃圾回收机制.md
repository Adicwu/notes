> 指浏览器对无使用变量的一种回收机制

[原文链接](https://juejin.cn/post/6995706341041897486)

### 内存管理

在js中有两种变量类型，一种叫`基础数据类型（值类型）`，另一种叫`引用数据类型（引用类型）`；两种都存放在`栈内存`中，而不同的是，值类型在存放时是`名称-栈`对应，而引用类型则是`名称-地址`对应，而所谓的地址，则统一存放在了`堆内存`中



### 垃圾回收

> 因为V8引擎对浏览器的内存占用做了一定的限制（64位-1.4G 32位-0.7G），因为其设计初期就没过多考虑大占用情况；而且因为浏览器在执行垃圾清理时，会影响js线程暂停，导致主系统卡顿

#### 引用法/标记法

**引用法：**对每一个对象的引用进行计数统计，当此计数为0时，则立刻回收其对象；此方法无法解决对象互相引用，从而导致的内存泄漏；此方法已被淘汰

**标记法：**每一个变量都有其可达性（如从根实例window往下子节点递归遍历，是否能直接被获取到，比如执行的方法内部定义的变量，就无可达性）。此方法会每隔一段时间进行，如果其无可达性，则被回收

#### 内存间隙

由于内存的顺序放置，在我们删除内存中的指定位置时，会造成很多间隙；早期我们通过下一次往内存中放东西时，遍历间隙并获取其大于当前放入东西的间隙，然后放入其中，这样能有效利用间隙空间；在后来实现了**标记整理**算法，在标记结束后会整理一次内存，清除里面的间隙



#### 分代回收

此算法是用于回收对象的。V8将`堆内存`划分为两个空间：新生代和旧生代，分别存放短期存活对象与长期存活对象；

**新生代**中采用`Scavenge拾荒者`算法，将其内部再次划分为`from-space`和`to-space`两个空间，在工作时将`from-space`内容复制到`to-space`，然后再释放`from-space`中的非活动对象（判断其可达性），最后将`from-space`和`to-space`空间内容互换；

如果新生代内的某对象经历了两次新生代处理后，仍然存在于新生代，则会被移入生时代，此操作称为`晋升`；

**旧生代**则采用`Mark-Sweep算法`，将其内部进行扫描，标记其活动对象，再次进行扫描，清除未标记对象；由于内存是一种队列结构，其内部发生了清除，就导致其存在很多空位；于是有了`Mark-Compact标记整理算法`将其空间进行整理，将剩下的内容整理到内存的一侧，整理完成后，直接一次性处理其他边界内存



#### 全停顿

由于js是单线程执行，那么就会导致垃圾回收与代码执行冲突，而此时，浏览器会选择优先执行垃圾回收，而且这个等待过程，就是`全停顿`，这种情况常出现与老生代对象中，停顿时间长了，就导致了页面卡顿；`Orinoco优化`则指应对这种情况的优化

