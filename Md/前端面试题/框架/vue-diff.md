> 一种平级的数组对比算法

对于根级来说，我们会对比其tag与key，然后对比其text做出对应的更新

对于子级（节点列表来说），采用了一套优化的循环对比方案（头头、尾尾、头尾、尾头）的一种双端（双指针）操作

**注意，以下比对方法是递进的比对方法，且一旦比对失败，就会停止当前比对方法，并进入下一个比对方法（比如头头比对失败，直接进入尾尾比对，尾尾比对失败，再进入头尾比对....直到乱序比对）**

- 头头、尾尾：用于操作两列表长度不同但头或尾以及其中间相同的情况（相当于两列表长度不同），来对头或尾进行插入或添加操作；然后同时向后或向前移动指针，继续重复操作

  ```
  // 头头常见情况
  a b c
  a b c d
  左往右，同位比对，相同则指针同时往右移，直到无法移动，则相当于结果为 添加d到末尾
  
  // 尾尾常见情况
  e a b c
  a b c
  右往左，同位比对，相同则指针同时往左移，直到无法移动，则相当于结果为 直接删除e
  ```

- 头尾、尾头：用于操作两头或两尾不等的情况，将其头尾进行比对，相同则进行位置互换；然后一端向前、一端向后移动指针（相当于两端都在向内移动），继续重复操作

  ```
  // 头尾常见情况
  a b c d
  d c b a
  第一行左往右，第二行右往左，交叉比对，相同则指针向其方向移动，并将当前内容移动到第一行的末尾（d的后面），上述执行过程如下：
  abcd-bcda-cdba-dcba
  
  // 尾头常见情况
  ```

- 乱序-映射map：用老队列生成映射map（key->值），采用双指针往后走；新队列当前指针值与map对比：如果存在且与老队列位置不同，则将此项插入到老队列指针前一位，然后新队列指针往后移且老队列此项的原位标记为空；如果新老队列位置项相同，则新老指针同时后移一位（老队列在移动时，如果遇见空指针，则继续后移）

  ```
  // 举个例子
  a b c d
  b m a p c q
  第一行生成映射map，方便后续能直接判断第二行某位置是否在第一行出现，上述执行过程如下：
  bacd-bmacd-bmacd-bmapcd-bmapcqd-bmapcq
  ```

### 常见面试题回答

#### key的作用，为什么不推荐使用下标作为key

key可以有效的判断两者是否相同，有利于更新优化

当我们使用下标作为key时，假设有如下场景：列表1 2 3，其key为 0 1 2（相当于1-0 2-1 3-2），此时我们为列表头部增加一个0，则此时对应的key为 0-0 1-1 2-2 3-3，也就导致了列表子项的key发生了偏移；由于diff算法的对比特性，相当于 012 与 0123 对比，采用 头头 方案，于是将012依次判断，并在末尾添加3（此现象可观察真实节点的变动位置验证）；而如果采用独自的key，将上述 改为 abc 与 dabc进行对比，则就会采用 尾尾 方案，并在头部添加d

