#### 函数组件与类组件

- 编程思想不同，一个是类，一个是函数
- 函数组件本身就相当于一个render函数，类组件则不是；所以类组件需要单独创建并保存类实例；
- 类组件是一个实例保存，所以不需要考虑变量问题。函数组件由于是render本身，所以会被频繁执行，所以react对其实现了一个 值捕获收集 的特性，用于节约性能；由于这个特性，也导致函数组件存在很频繁的闭包问题，故更推荐编写纯函数，或者使用特殊手段处理（如 ref、setState的回调写法等等）
- 函数式组件没有类组件那种实名制的生命周期，需要通过useEffect等骚操作，且有些直接不支持，如shouldComponentUpdate的渲染可控（虽然有React.memo，但无法自己定义规则）
- 类组件通过hoc、类继承等方式实现逻辑复用；函数组件则多使用hooks



#### setState

- 在生命周期和合成事件中，赋值操作是异步的，需要使用第二个参数回调来获取最新state
- 在宏任务和原生事件中，赋值操作是同步
- 批量更新可以通过Object.assign减少操作，也可以使用一些特殊数据类型，如immutable和immer
- 是宏任务还是微任务。这是一个伪命题，实际上setState是一个同步任务，但其行为像异步任务（节点事件中，调用先后会变化）。因为合成事件的原因，在执行完默认的事件后，会触发一下state更新，就导致了更新延后。而如果事件本身是一个异步任务，则会导致跳出这种结构，让调度任务来执行state更新



#### 合成事件

- 对于react来说，其节点的事件会被统一封装，并通过事件代理的机制挂载到一个根节点（如body），然后通过body来集中管理这些事件，拥有更好的性能与管理性

- 合成事件的回调参数也与原生的event不同，合成事件对其进行了封装

- 合成事件的执行时间在自己执行点的原生事件之后，根节点之前

- 对于事件绑定来说，无论是使用bind还是箭头函数来改变其事件参数，都会导致创建无用变量，更建议在constractor中进行绑定（也可以在函数声明时使用箭头函数）




#### 组件渲染

react中的组件结构是一个整体，而不像vue中是单独的块，这就导致了顶层触发render时会导致子组件全部进行更新遍历。对于类组件来说，render就是其类里面的render函数；对于函数组件来说，函数就是render。所以我们需要手动对不需要更新遍历的组件进行操作，常规有：

- 类组件生命周期shouldComponentUpdate，通过返回bool来判断是否触发更新
- 类组件基础对象PureComponent，自动化的shouldComponentUpdate生命周期版本，其会自动比较props和state，不过这是浅比较
- 组件转换函数memo，前两者的结合体，第一个参数是组件实例，第二个是shouldComponentUpdate



#### Fiber

它是vnode与真实dom的一个中间树形结构状态。他将遍历任务拆分成了块状，方便我们的时间分片调度来执行。

它本身的一个结构特性，方便了我们 组件实例存储、组件状态存储、组件依赖收集、更新比对等



#### requestIdleCallback

此api传入一个回调，并在浏览器空闲时执行这个回调；但其不支持ie与Safari，故需要手动实现

采用requestAnimationFrame\MessageChannel实现：

**requestAnimationFrame** 传入一个回调，在浏览器下次重绘时执行，回调携带一个参数，为当前回调开始的时间

**MessageChannel** 页面通讯api，是一个宏任务。不使用setTimeout是因为其有最小阈值（4ms）

requestAnimationFrame回调返回的时间加上一帧的执行时间（1000/60 ms），则为当前帧结束时间；根据任务轮询的特性（宏任务队列开始执行，判断并执行微任务，浏览器渲染，开始下一个宏任务），故在requestAnimationFrame中触发postMessage（创建一个宏任务），则会被推迟到浏览器渲染后执行，将onmessage接收时获取当前时间，与之前的帧结束时间对比，方可判断空闲时间



#### Redux

一个发布订阅的库



#### useEffect

> 其第一个参数接受一个回调，回调返回函数（可不返回）为此effect销毁时调用的函数；第二参数是需要收集的依赖

1. 第一个参数不能是异步函数async这种，因为这样会导致执行阻塞，也会导致默认返回一个新的promise
2. 第二个参数在判断不同时是浅比较（Object.is），所以请谨慎传入引用类型依赖（会导致无限执行）
3. 切勿在回调中修改依赖内容，会导致无限循环