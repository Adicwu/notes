## js之版块分析

------

### 隐性操作

1. 使用`console.log`打印方法时会默认执行`Funnction`原型上的`toString`方法

2. 对象的属性名称始终会被`toString`（将对象当做属性名称，则会变成[object Object]）

3. `+-*/`触发数据隐式转换

   ```javascript
   num + fn：两者转换成字符串
   num + null/undefined：两者转数字，null为0，undefined为NaN
   num + []/{}：两者转字符串，[]相当于jion，{}为[object Object]。如果{}在首位，则会认为是空执行段
   num + bool：两者转数字
   str + 任意：两者转字符串
   ```

4. `==`在比较不同数据类型时会有一套规则来隐性数据类型转换

5. `let和const`会导致临时性锁区（内部使用let定义外部已经定义的同名变量，且在内部定义前使用此变量，会报错）

6. `isNaN和Number.isNaN`。前者是全局方法，后者是`Number`原型方法，两者都是判断值是否为`NaN`，差别在于前者会将传入内容先执行`Number()`，后者不会，所以两者对字符串`'NaN'`判断，前者输出`true`，后者输出`false`

------

### 数据、类型

##### 1）比较 ==

> ==在比较不同的数据类型时，会将两者转换为相同的数据类型再	比较

1. 两个对象或两个数组比较，都不相等，因为其判断的是内存地址；
2. NaN和谁都不相等，包括他自己；
3. null和undifined值相等，但是数据类型不同，null为Object，undifined为undifined；
4. 对象和字符串比较，把对象转换为字符串再比较
5. 除了1-4的情况，其它比较都转换为数字比较。对象转数字：先转换为字符串，在转换为数字；字符串转数字：只要内容存在非数字，则为NaN；布尔转数字：true 1、false 0；null转数字0；undifined转数字NaN；数组转数字，先转为字符串，再转数字；

##### 2）大小 > <

1. 数组比较，按照字典序比较，先比第一项大小，相同再比第二项

#### 3）var、let、const

##### 区别

1. const在定义后不能更改，引用类型可以更改其属性
2. const、let不能重复定义、不存在变量提升，具有块级作用域，其存在暂时性锁区，如果块中有使用其赋值，而外部有同名函数，则会报错
3. var存在变量提升，可先使用后定义，可重复定义

##### 实现原理

> const>let>var优先被js解析，因为const不能被修改栈内存在的值和地址，最后验证var

##### 4）类型检测

1. `typeof aa`：返回对应的类型字符串。无法准确判断数组和null

   ```javascript
   typeof null // 'object'
   typeof {} // 'object'
   typeof [] // 'object'
   ```

2. `aa instanceof Xxx`：aa是否属于Xxx的原型，返回bool；只能判断实例化的内容，且无法准确判断数组，无法判断Symbol类型

   ```javascript
   // 以下内容string\Boolean\同理
   1 instanceof Number // false
   Number(1) instanceof Number // false
   new Number(1) instanceof Number // true
   
   [] instanceof Object // true
   [] instanceof Array // true
   ```

3. `aa.constructor`：返回aa的constructor属性值，能判断所有类型，但如果判断的对象原型发送改变，结果也会改变，存在可变动性

4. `Object.prototype.toString.call(aa)`：可简写`toString.call(aa)`，返回aa的详细数据类型字符串，最精确，配合`Xxx.prototype.toString`判断是否相同

#### 5）特殊值判断

1. 是否为NaN：通过自己和自己不相等的特性，如：`AA!=AA`
2. 当前数组项是否为empty：原数组.hasOwnProperty(当前项下标) 

------

