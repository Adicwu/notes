## js之意义解析

------

1. 作用域。js中的作用域属于词法作用域（静态作用域），他会在定义的时候就决定好其作用域内容；全局和函数作用域（附加函数传参作用域）。var存在变量提升，无论使用var将变量定义在同一作用域的任何位置，他始终会被放到执行最前面去定义，等运行到定义的位置时再赋值，let和const则没有。块级作用域能访问全局内容，反之不行

2. 引用类型。数组、对象属于引用类型，当一个变量数组给其他变量赋值时，其他变量改变，变量数组也会改变，只是浅拷贝

3. +、-会做什么。会将数据隐式转换为number，number包含一个特殊类型NaN，当对非数字强行转换时则返回这个

4. Symbol()。创建出来的数据是唯一的，尽管他的值相同；对象的属性名称不能是对象，如果传入对象，则会默认将传入对象转换为字符串，为‘[object Object]’

5. 匿名函数在创建时命名。则在其本身内部能通过函数名称调用，外部不行，且内部再次给函数名称赋值并不会改变函数内容

6. void 0。void是js中的一个函数，接受一个参数，始终返回undefined

7. 传参变量。当变量以参数的方式传递进入函数时，函数内改变变量并不会导致外部改变，而对象属性则可以添加，因为其对象属性是内存地址。方法在传参时会单独开辟一个传参作用域，如果在之前没有定义，则优先使用之前或者外部的，不会在方法内找

9. 原型链。在js中，为了处理同一个对象与不同实例化此对象的内容间创建共同属性，于是有了`prototype`这个属性，所以他其实只存在于函数；而在es6之前，我们创建类时是一个函数，es6后的这个函数就相当于class里的构造器`constructor`；`__proto__`是es6之前每个对象上都有的属性（此属性已被淘汰），也就是实例化对象后才会存在的内容，他指向了对象的构造函数的原型（`obj = {}; obj.__proto__ === obj.constructor.prototype`），；

10. 隐式bool。除了`0/NaN/null/undefined/''`是false，其他都是true

11. 数据不存在的返回值

    ```
    不存在的对象、数组属性：obj.a、arr[x]，返回 undefined
    定义未赋值，返回 undefined
    未定义，报错 not define
    ```

12. 变量提升。优先级：函数声明 > arguments > 变量声明；当存在函数与var变量同名时，且函数先定义的情况下，var变量将不再被赋值为undifined，而是函数本身（注意，函数的变量提升是声明和赋值是同时存在的，而非如变量一般先定义后赋值）

13. 作用域。es5前只有全局作用域和函数作用域，es6增加了块级作用域let和const

14. 函数内访问变量。查找变量是从函数声明的位置向外层作用域中查找

15. es6声明变量的六种方法。var/let/const/function/import/class

16. `BigInt`。在js中无法精确表示53个二进制位以上以及大于等于2的1024次方的数值，而`BigInt`是ES2020中为了解决这个问题定义的第八种数据类型，它只表示整数且没有位数限制，定义出的值结尾带n，且这个值不能使用+号定义，如`+1n`会报错

17. 函数尾调用。指在函数的最后一步操作返回一个新函数，且新函数不能用到原函数的内部定义变量。这个只对Safari有用

18. 柯里化函数。指将多参数函数转成单参数的形式

19. class细节。es6中的class会默认创建一个constructor，尽管你没有定义，且这个构造器会默认返回实例对象，当然也可以手动改变。所有实例共享一个原型对象，但尽量不要使用`__proto__`添加属性

20. 具名自执行函数。名称无法被修改

21. 隐式死循环。Math.pow(2, 53) == 9007199254740992为最大可表示数值，会导致死循环，也会导致运算结果出错

22. 会跳过empty的数组方法。filter、map

23. 数值精度问题。在0.x的浮点数中，x>2时，减数小于被减数且仍为0.y，会导致结构与正常结果存在偏差。可使用bigint 、第三方插件处理

24. 对Infinity求余。返回NaN

25. arguments的值不被外界影响。非严格模式在函数传入值包含剩余参数`(...arg)`\默认参数`(a=4)`\解构赋值`({x,y})`时

26. parseInt第二个参数。意为基数默认为0，当它小于2（不包含0），大于36时，会返回NaN

27. 逗号操作符。会对每个对象求值，然后返回最后一个，如`1,3,2`返回2、`1+1,2+1,31+1`返回32

28. 在函数内定义且在同一地方执行的内层函数（概括自执行函数），在调用时会默认执行在外层函数执行区域

29. 事件流。当一个事件产生时的过程

30. 自执行函数。创建时执行的函数，隔离作用域，避免环境污染

31. 事件三要素。获取元素，注册事件，程序处理

32. if判断细节。判断条件中定义方法是无效的，不会产生任何后果，会默认当成true

33. typeof。用于判断数据类型，但不能很好的区分出数组和对象，都会返回object；判断一个不存在的值会返回undifined

33. 基本类型：String、Boolean、Number、Undefined、Object、Null、Symbol、BigInt

34. 闭包。指能够访问外部自由变量的函数。理论来说，js中所有函数都是闭包，因为都能访问外部变量；而我们常说的闭包，一般指函数+能访问外部变量的函数，可以理解为函数A中返回一个函数B，此时的函数B能访问函数A中定义的变量

35. this。由于函数的引用类型性质，导致其在内存存储中实际上是同列排布的，在使用时直接根据其内存地址取出操作；函数又因为可以在不同的地方执行，而此时就需要一种机制来获取当前运行地方，于是有了this；this在函数内部，用于指代函数的当前运行环境。故this的指向为执行的地方

36. 任务轮询。js由于是单线程执行，所以就需要一个独特的事件轮询机制来处理不同类型的任务，而这种任务大概分为三种：同步任务>微任务（promise等）>宏任务（setTimeout等），优先级如上所示。在执行同步任务时，所有微任务会进入一个微任务队列（宏任务同理），等待所有同步任务执行完成，才开始逐个执行微任务。注：JS引擎所管理的执行栈中的事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染

37. 尾调用优化。尾调用就是函数在结束时调用另一个函数（结束时不需要是最后一行，只要是最后一步操作就行；其不能有多余的计算操作）；而尾调用优化就是，尾函数不使用主函数中的内容，那么在执行尾函数时，主函数的栈就会被销毁，从而形成优化。注意，尾调用优化只存在于Safari，且需在严格模式下才会有用（因为函数体内的arguments与caller会跟踪执行内容，导致失真，而严格模式下两者是无法使用的）

38. 尾递归优化。顾名思义，就是在尾部执行自身；而尾递归相较于普通递归来说，其不会发生栈溢出，相对节省内存。而尾递归优化就必须遵循尾调用优化，如果想无论条件的情况下使用尾递归优化，那就需要将递归巧妙的转换为循环

39. 在函数参数默认值中，如果在多参数情况下，中间参数想不传，左右参数需要传，此时中间参数传入undefined即可（不能传null）

40. 函数的length属性。此属性代表 定义函数时的 未设置默认值的 参数 个数；同理，rest参数也不会计入统计

41. 对象可枚举性。值对象属性是否能被某些操作所遍历处理，如：`fo in`、`Object.keys`、`JSON.stringfly`、`Object.assign`；此属性可通过`Object.defineProperty`设置，出现此属性是因为避免遍历出对象原型上的内容，如`length、toString`等

42. iterator。俗称遍历器，用于遍历一些带有`Symbol.iterator`方法与其知道格式`next`的一种数据类型，如常见的：`数组、Set、Map、类数组对象`等有具体的子项顺序的结构，常见于`for of`搭配遍历使用；注意，对象本身并没有遍历器的方法，因为对象的属性并没有指定的顺序排列，需要使用者自己定义规则

43. 模块化加载原理与循环加载。加载原理对于commonjs来说，require执行时会在node环境中生成一个对象，这个对象拥有自己的id、exports导出内容、loaded是否已加载，最终在其他地方使用时直接引用同一个，并不会进行多次运行。对于大型项目来说，`模块a依赖模板b，模块b又依赖模块a`，这是很常见的情况，正常情况下会导致递归加载；而循环加载就是为了处理这种问题；

45. DOM事件模型；指我们DOM在触发一个事件时的事件流向：从document往内查找，直到找到事件触发源，并触发，这个叫捕获；接下来，从事件触发源往外查找，如果有同类型事件，则触发，这个叫冒泡。DOM提供了三个api来操作事件：addEventListener、removeEventListener、dispatchEvent

46. 通配符与伪元素；通配符无法作用于伪元素，除非通过继承 `*::after`，伪元素只能依赖于实际元素，并不是一个单独的元素

