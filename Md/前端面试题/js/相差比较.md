## js之相差比较

------

1. `apply、call、bind`。三个在function原型上的方法，用来改变this指向和传递参数。apply和bind传递参数为多个，apply会立刻执行，bind不会执行；call以数组的形式传递参数，且立刻执；bind不会立即执行，call参数为数组。参数传递0-3个时，apply与call性能消耗差不多，而超过3个时call消耗更少

2. 箭头函数和普通函数。1）箭头函数更为简洁；2）箭头函数没有prototype，也不能使用new实例化；3）箭头函数会将、内部this指向内部外一层，且无法被改变；4）箭头函数中没有arguments

3. `mouseover/mouseenter`。mouseover当鼠标移入自身以及其子元素时触发，对应mouseout；mouseenter当鼠标移入自身时触发，不包括子元素，对应mouseleave

4. `undefined/not define(undeclared)/null/''`。`undefined`指未定义内容，类型为`undefined`；`not define`指未定义变量(undeclared)，类型为报错；null指空对象指针，其没有构造函数，类型为`Object`，一般作为对象初始化内容；`''`为空字符串，类型为`String`

5. 事件绑定监听/普通事件。事件绑定监听支持一个元素绑定多个相同事件；普通事件会被后来者覆盖；两者可以同时存在且不影响对方

6. 基本类型/引用类型。基本类型无法被自带方法改变原本内容，比较时是比值；引用类型的值会被自带方法改变，比如数组和对象，比较时是比内存地址

7. `new`和`Object.create`。`Object.create()`方法创建一个空对象，这个对象的原型指向传递进入的原型链

8. `++i/i++`。前者先加后赋值；后者先赋值后加

9. `require/import`。require属于`commonjs`，用于读取并且执行js文件，并返回该模块的module.exports对象（没有则报错），在导出时是值拷贝，在编译时输出接口，加载模块是同步的， 只有加载完成， 才能执行后续操作；import属于`es6`，用于引入外部模块、脚本、对象或基本类型，在导出时是值引用，会生成外部模块的引用， 等到真正使用到该模块的时候才会去加载模块中的值

10. stack栈内存/heap堆内存。前者类似于内存条，存放值类型；后者类似于硬盘，存放引用类型

11. `break/continue`。两者作用于循环体内，前者跳出整个循环，后者跳出当前循环继续下一次循环

12. 对象中`obj.hasOwnProperty('xx')`和`'xx' in obj`的区别。前者是单纯在检查对象中是否存在指定属性，而后者是检查原型链是否存在指定属性

13. `&&/||/!!`。&&逻辑与，两端全真为真，有假为假；|| 逻辑或，两端有真为真，全假为假；!! 将后续内容强转为bool

14. new String和String。前者生成了一个字符串对象，属性名为每个字符串下标；后者生成一个字符串

15. +和-。+有拼接和逻辑运算；-只有逻辑运算

16. `__proto__\prototype`。实例化后的为`__proto__`，指向的`prototype`；原型上的为prototype；最好不要使用`__proto__`，此属性是es6之前为了在对象上增加内部属性的方法，且此属性只要求在浏览器上部署，其他环境非必要部署，请使用`Object.setPrototypeOf`代替

17. `new Obj`和`new Obj()`。表面上没有差别，如果是直接`new Obj`和`new Obj()`是没关系，但如果是`new Obj.xx`和`new Obj().xx`就不一样了，前者是实例化的`Obj.xx`，后者是实例化`Obj`再调用`xx`

18. 类型强转和隐式转换。前者一般是原型上的方法如`parseInt\Number\Boolean\parseFloat`；后者一般是不起眼操作`逻辑运算符：+-*/`、`判断：==/===`、`操作符：!`

19. 本地对象\内置对象\宿主对象。本地对象为js所定义的原生可实例化对象，如`Array\Object\String...`；内置对象为js所定义的不可实例化对象，如`Math...`；宿主对象指其依赖的运行环境内的对象，如浏览器内的`document\window\location....`

20. caller和callee。前者存在于方法的原型上，会返回执行当前函数；后者存在于函数内的arguments对象，返回当前函数

21. innerText和innerHTML。分为两个方向，读取和设置。读取来说，前者只会读取节点内的文本内容，后者会读取标签内所有内容；设置来说，前者会作为文本设置，后者会解析内容是否为节点然后设置

22. 函数作用域和this。函数作用域在函数定义的位置往上。函数的this在执行的位置往上。运行环境的this会在严格模式（use strict）下无效（箭头函数除外），webpack等环境中this无效原因是因为babel转义时使用了严格模式

23. join和toString。前者用于将数组按照传入内容合并为字符串；后者将指定内容转换字符串。join函数在不带参数时对于数组相当于toString

24. 组件化/模块化。组件化指将一块页面内容包括js、css、html抽离出来整合成一个组件；模块化指将相同的js功能抽离成一个模块

25. vdom和dom的差别：vdom不会立即重排，他会频繁修改数据，取其中最真实的dom修改部分修改，再重排

26. `for in/of`。in来自es5，用于循环数组或者对象，结果为下标或者属性名称；of来自es6，用于循环数组、字符串，结果为值

27. 冒泡和捕获。由于html的层级关系，所以需要一套规则来处理事件处理顺序。前者由ie团队提出，定义事件在触发时逐层往上触发；后者则相反，先触发最外层再逐层往下触发。一般通过addEventListenr的第三个参数修改机制(默认false冒泡，true捕获)

28. children/childNodes。两者都是用于获取节点下的子节点；children是已被淘汰的属性；childNodes在部分浏览器时会包含`空白文本节点`（如节点之间的换行符等），需要结合`nodeType`属性进行类型区分

29. css中的opacity、visibility、display-none；opacity与visibility只会发生重绘，opacity偏向动画，可设置过渡，visibility在隐藏的同时且无效了其事件与遮罩效果；display-none会发生重排

30. Map与WeakMap。两者都是新增的数据结构，同样的键可以为任意类型，不同的是WeakMap的键为弱引用，也就是说当其引用被赋值为null时，为真正意义的引用销毁，如下

    ```javascript
    const aa = {}
    const bb = aa // 由于bb对aa的引用，导致{}仍然存在于数组
    aa = null
    ```

31. `'hellow'` `new String('hellow')` `String('hellow')`。分别对应 封装类型、实例化对象、转型函数；封装类型最常用，它相当于在编译时使用 实例化对象 后返回的值；转型函数更常见于类型转换；实例化基本上不用，因为编译环境会为你做这件事

32. `onload` 和 `DOMContentLoaded`。`onload` 是指当前页面所有资源加载完成后触发的，包括了HTML文档、样式、多媒体资源等；而`DOMContentLoaded`只是HTML文档加载完成后触发

33. script标签的 `async`与`defer`。这两个属性都是用于异步加载js文件的：对于`async`来说，js会在HTML文档解析时进行下载，一旦下载完成，就会暂停HTML文档解析，然后来执行js文件，多个`async`间是乱序的；对于`defer`来说，js会在HTML文档解析时进行下载，等待下载完成且HTML文档解析完成后，执行js文件，多个`defer`间是顺序的
