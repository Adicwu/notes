### 请求缓存

是一种节约性能的概念，通过指定方案，来节省客户端与服务器间的请求性能

### 强缓存

> 给定具体的缓存生效时间，在其时间内部再进行相同的请求，直接寻找本地缓存，不管你服务器是否存在资源更新

#### Expires

早期的强缓存方案，通过传输服务器固定时间来给定缓存过期点；由于其单一性，导致缓存判断并不合理（如时间不准的情况），故已被淘汰；现在一般为Cache-Control，它应用了更加完善的方案

#### Cache-Control

常见值：

- private：仅浏览器可以缓存（默认值）；
- public：浏览器和代理服务器都可以缓存；
- max-age=xxx：过期时间单位秒；
- no-cache：不进行强缓存；
- no-store：不强缓存，也不协商缓存）

### 协商缓存

> 给定多种关键请求头字段，判断服务器与浏览器是否存在差异

常见组合：`Etag`和`If-None-Match`、`Last-Modified`和`if-modified-since`

#### Etag和If-None-Match

Etag由一些关键信息（文件修改时间、文件长度等）根据不同的环境（如nginx express）对应的不同规则进行生成（如nginx中为`文件最后修改时间16进制-文件长度16进制`），`W/`代表弱校验（大小写敏感）

If-None-Match是用于浏览器与服务器进行判断的媒介。在请求时，请求头会携带If-None-Match字段（值为上一次此请求响应时返回的Etag），服务器接收到后将生成新的Etag（不管新的Etag与旧的Etag是否不同），然后与If-None-Match进行比对判断是否命中缓存（304或200），并返回新的Etag

#### Last-Modify和if-modified-since

Last-Modify是请求时浏览器返回的一个响应头，其记录请求的资源最后修改时间

if-modified-since为再次请求某资源时，上一次请求返回的Last-Modify，然后通过请求头发送给服务器，进行比对判断是否命中缓存

#### 两组优先级

看具体的服务器实现策略，express中Etag优先级更高。当然，这些都是请求头与响应头，完全可以根据自己的思路来改变

### http 缓存头部字段

- If-Modified-Since：对应Last-modified，在下一次发送时携带，来对比时间是否更新资源
- Last-modified：资源最后修改时间
- ETag：独有资源标识符
- If-None-Match：类似于If-Modified-Since，且优先级比其高，不过这个是使用ETag。其比较使用弱算法（结构相同则相同）。
- Cache-Control：缓存控制，支持多值。`max-age=<seconds>资源有效时长，单位s、`no-store不允许缓存`、`no-cache使用缓存前需先到服务器验证`、`private客户端缓存，代理服务器不能缓存`、`public均可缓存`、`s-maxage=<seconds>代理缓存有效时长`
- Expire：资源失效时间，优先级低于Cache-Control，已废弃
- Vary：代理服务器实现缓存服务
- Via：记录经过的代理节点的信息
- X-Forwarded-For：当前节点的请求方的 IP 地址，非标准
- X-Real-IP：记录客户端的 IP 地址