### WXML 语法

```html
/*
 * 列表循环
 * 注意，key可以直接是子项对象的属性的名称；如果是简单的数组，想子项作为key，则使用 *this
 */
<view wx:for="{{list}}" wx:key="name">{{item.name}}</view>
```

```html
/*
 * 条件渲染
 */
<button wx:if="{{flag}}">add name</button>
<button wx:elif="{{flag2}}">update name</button>
<button wx:else>remove name</button>
```

```html
/*
 * 模板插槽
 */
<template name="staffName">
  <view>
    FirstName: {{firstName}}, LastName: {{lastName}}
  </view>
</template>

<template is="staffName" data="{{...staffA}}"></template>
```

```html
/*
 * 双向绑定
 */
<input class="ad-input" type="text" model:value="{{value}}" />
/*
 * 双向绑定-自定义组件,
 * xx-value为传入参数名称，为组件内properties的属性
 */
<ad-input type="text" model:xx-value="{{says}}" />
```



### 自定义组件

> WXML 节点标签名只能是小写字母、中划线和下划线的组合，故组件名称推荐xx-xx-xxx写法，且自定义组件不能以wx-开头；
>
> 自定义组件的样式是内部独立的， app.wxss中定义的全局样式不会影响自定义组件内样式

**钩子**

```javascript
Component({

  behaviors: [],

  properties: {
    myProperty: { // 属性名
      type: String,
      value: ''
    },
    myProperty2: String // 简化的定义方式
  },
  
  data: {}, // 私有数据，可用于模板渲染

  lifetimes: {
    // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
    attached () { },
    moved () { },
    detached () { },
  },

  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
  attached () { }, // 此处attached的声明会被lifetimes字段中的声明覆盖
  ready () { },

  pageLifetimes: {
    // 组件所在页面的生命周期函数
    show () { },
    hide () { },
    resize () { },
  },

  methods: {
    onMyButtonTap(){
      this.setData({
        // 更新属性和数据的方法与更新页面数据的方法类似
      })
    },
    // 内部方法建议以下划线开头
    _myPrivateMethod(){
      // 这里将 data.A[0].B 设为 'myPrivateData'
      this.setData({
        'A[0].B': 'myPrivateData'
      })
    },
    _propertyChange(newVal, oldVal) {

    }
  }

})
```

**注册**

```json
// 注意，此属性定义在页面或组件的的xxx.json中，如果定义在入口的app.json中，则视为全局组件
{
  "usingComponents": {
    "component-tag-name": "path/to/the/custom/component"
  }
}
```

**slot**

```html
/*
 * 基本
 * 注意，默认情况下只支持单默认插槽，具名插槽请看下一个代码块
 */

// 组件ad-view
<text>
    <slot />
</text>

// 页面A
<ad-view>123</ad-view>
```

```html
/*
 * 具名插槽
 */
 
 // 组件ad-view
<view class="wrapper">
  <slot name="before"></slot>
  <view>这里是组件的内部细节</view>
  <slot name="after"></slot>
</view>

Component({
  options: {
    multipleSlots: true // 在组件定义时的选项中启用多slot支持
  }
})

// 页面A
<ad-view>
    <view slot="before">这里是插入到组件slot name="before"中的内容</view>
    <view slot="after">这里是插入到组件slot name="after"中的内容</view>
</ad-view>
```

**样式**

- 默认情况下，自定义组件的样式文件只会影响自身，全局中定义的样式处理标签名称，也不会影响组件

- 组件的样式影响可通过更改组件内的`styleIsolation`属性值

  ```javascript
  Component({
    {
      /*
       * 默认为isolated
       * isolated 启用样式隔离
       * apply-shared 允许引用它的页面样式可以影响
       * shared 页面和自定义组件都能影响它
       * 如果使用Component定义页面时，请查看文档 https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html
       */
    	"styleIsolation": "isolated"
    }
    ...
  })
  ```

- 引入指定名称的外部样式类

  ```html
  // 组件ad-view
  Component({
    // 引入外部的my-class样式
    externalClasses: ['my-class']
  })
  
  // 页面A
  <ad-view class="my-class"/>
  <ad-view my-class="my-class my-color"/> // 传入多个class
  ```

- 强制使用外部的样式

  ```html
  // 页面A
  <ad-view class="~my-class"/> // 任意外部的my-class
  <ad-view class="^my-class"/> // 任意父级my-class，这个复活可多写几个，向上叠加获取其祖级
  ```

- 拒绝组件上的行内样式传递

  ```html
  // 组件ad-view
  Component({
    options: {
      virtualHost: true
    }
  })
  
  // 页面A
  <ad-view style="color: red"/> // 失效
  ```

  **事件**

  ```html
  // 页面A
  <ad-view bind:bind:vertify="addList" />
  
  // 组件ad-view
  ...
  methods: {
  	xx() {
  		/*
  		 * 事件派发
  		 * @param 事件名称
  		 * @param 事件回传参数
  		 * @param {object} 配置 bubbles是否冒泡，默认false composed是否穿越组件边界，默认false capturePhase是否拥有补货阶段，默认false
  		 */
      	this.triggerEvent('vertify', 123, {
  			...
          })
      }
  }
  ...
  
  ```

  

[组件生命周期 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html)