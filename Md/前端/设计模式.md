[原文地址](https://juejin.cn/post/6844904032826294286)

### 工厂模式

#### 介绍

使用一个工厂类，来对其子分支类进行实例化，使用时不会直接接触到子类，使用者只需要知道子类名称即可

#### 实例

```javascript
class Product {
    constructor(name) {
        this.name = name
    }
    init() {
        console.log('init')
    }
    fun() {
        console.log('fun')
    }
}

export class Factory {
    create(name) {
        return new Product(name)
    }
}

// use
let factory = new Factory()
let p = factory.create('p1')
p.init()
p.fun()
```

### 单例模式

#### 介绍

一个类只有一个实例化对象，节约性能开销

#### 实例

```javascript
class Vuex {
  state: {
    name: 'adic';
  }
}
let instance;
export function getVuexInstance () {
  if (!instance) {
    instance = new Vuex();
  }
  return instance;
}

// use
let a = getVuexInstance();
a.state.name = 'lucy'

let b = getVuexInstance();
b.state.name // lucy
```

### 适配器模式

#### 介绍

将接口封装为另一个接口，常用于第三方api的封装，可降低耦合（如项目刚开始使用原生请求，后来更换为axois）

#### 实例

```javascript
// 下列使用的axios为一个请求依赖
export const $ = {
  get(...args){
    return axios.get(...args)
  }
  post(...args){
    return axios.post(...args)
  }
}
```

### 装饰者模式

#### 介绍

类似于继承的特性，将一个类进行扩展，且不影响原本的类，用于扩展业务

#### 实例

```javascript
class Dog {
    jump() {
        console.log('dog jump')
    }
}
class SuperDog {
    constructor(dog) {
        this.dog = dog
    }
    standing() {
        console.log('我站起来了！')
    }
}

// use
const liliS = new SuperDog(new Dog())
liliS.standing()
```

### 代理模式

#### 介绍

做一件事时，将这件事交给另一个人，让他在这件事在合适的情况下做。用于部分代理，节约性能，降低耦合

#### 实例

```html
<ul id="ul">
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>

<script>
  // 列表事件监听交给其父来处理，就不需要每个列表项来监听
  let ul = document.querySelector('#ul');
  ul.addEventListener('click', event => {
    console.log('列表里的', event.target, '被点击了');
  });
</script>
```

### 外观模式

#### 介绍

类似于`优雅降级`的一种模式，将一个接口封装，使其使用时更加方便

#### 实例

```javascript
// 处理兼容性
function addEvent(el, ev, fn){
    if (el.addEventListener) {
        el.addEventListener(ev, fn, false)
    } else if (el.attachEvent) {
        el.attachEvent('on' + ev, fn)
    } else {
        el['on' + ev] = fn
    }
}

// 封装接口功能
function stopEventContinuation(e){
    e.stopPropagation();
    e.preventDefault();
}
```

### 观察者模式

#### 介绍

使多个观察者对同一个对象进行监听，在被监听对象改变时，同时告诉所有观察者

#### 实例

```javascript
// 监听对象
class Subject {
  constructor() {
    this.state = 0
    this.observers = [] // 观察者队列
  }
  getState() {
    return this.state
  }
  setState(state) {
    this.state = state
    this.notifyAllObservers()
  }
  // 通知所有观察者
  notifyAllObservers() {
    this.observers.forEach(observer => {
      observer.update()
    })
  }
  // 增加观察者
  attach(observer) {
    this.observers.push(observer)
  }
}

// 观察者
class Observer {
  constructor(name, subject) {
    this.name = name
    this.subject = subject
    this.subject.attach(this)
  }
  update() {
    console.log(`${this.name} update, state: ${this.subject.getState()}`)
  }
}

// 测试
let s = new Subject()
let o1 = new Observer('o1', s)
let o2 = new Observer('02', s)

s.setState(12)
// o1、o2接到通知，并触发update方法
```

### 状态模式

#### 介绍

没get到应用场景

### 迭代器模式

#### 介绍

es6中的Iterator迭代器就是这种写法，没get到应用场景

### 桥接模式

#### 介绍

将抽象部分与它的实现部分分离，使它们都可以独立地变化，降低耦合，提高扩展性

#### 实例

```javascript
class Color {
    constructor(name){
        this.name = name
    }
}
class Shape {
    constructor(name,color){
        this.name = name
        this.color = color 
    }
    draw(){
        console.log(`${this.color.name} ${this.name}`)
    }
}

// use
let red = new Color('red')
let yellow = new Color('yellow')
let circle = new Shape('circle', red)
circle.draw()
let triangle = new Shape('triangle', yellow)
triangle.draw()
```

### 组合模式

#### 介绍

没get到应用场景

### 原型模式

#### 介绍

继承的概念，将原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象，提高复用性，降低耦合度

#### 实例

```javascript
class Person {
  constructor(name) {
    this.name = name
  }
  getName() {
    return this.name
  }
}
class Student extends Person {
  constructor(name) {
    super(name)
  }
  sayHello() {
    console.log(`Hello， My name is ${this.name}`)
  }
}

let student = new Student("xiaoming")
student.sayHello()
```

### 策略模式

#### 介绍

创建同类型但不同过程的内容集合，最终通过相同的方法使用不同的参数调用。利于统一管理，降低耦合

#### 实例

```javascript
// 集合
const strategies = {
    isEmpty(arr){
        return arr.length > 0
    },
    hasNumber(arr){
        return arr.some(item=> typeof item === 'number')
    },
    hasStr(arr){
        return arr.some(item=> typeof item === 'string')
    }
}

class Validator {
    test(arr, verifyName){
        return strategies[verifyName](arr)
    }
}
```

### 享元模式