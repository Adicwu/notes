## 对象

#### 获取：

- obj.key、obj[key]：获取对象中key的值
- Object.keys(obj)： 获取对象中的所有键的内容
- Object.values(obj)： 获取对象中的所有值的内容
- Object.entries(obj)/fromEntries()： 获取对象中的键、值，将两者合并为数组/反向操作
- Object.assign(obj1,obj2...)：合并对象
- delete obj.key：删除obj的key属性
- xxx in obj/obj.hasOwnProperty(xxx)：监测对象的原型链是否存在指定内容
- 

------

#### 增强写法：

```javascript
let str = 'xxx'
let obj = {
	str, //相当于str: str
	[str + 's']: 'emms', //相当于xxx:'emm'
	handle() { //与handle:function(){}类似，同样支持async，但无法被new实例化
		console.log(super.str) //super获取对象原型上的str，不支持函数表达式，这里输出x1
	},
}
obj.__proto__.str = 'x1'
```

```javascript
//链判断运算符ES2020，仅供尝鲜，用于处理多层对象判断取值
let obj = {
	adic: { sex: 1, age: 18 }
}
console.log(obj?.lucy?.xx || 1) //es2020
//console.log(obj && obj.lucy && obj.lucy.xx || 1) //es2020之前      
            
//扩展
// obj.handle?.() // 相当于obj.handle && obj.handle()
```

------

#### 设置：

```javascript
let arr = {
	name: 'adic',
	age: 18
}
//设置对象属性
// Object.defineProperty(arr,'name',{
// 	value: 'bob',//设置值
// 	writable: false,//是否可更改
// 	enumerable: false,//是否可遍历
// 	configurable: false,//是否可删除
// })
//获取对象属性
// console.log(Object.getOwnPropertyDescriptors(arr))
// Object.defineProperties(arr, {
// 	name: {
// 		value: 'bob',
// 		writable: false,
// 		enumerable: false,
// 		configurable: false,
// 	},
// 	age: {
// 		value: 18,
// 		writable: false,
// 		enumerable: false,
// 		configurable: false,
// 	}
// })

//禁止像对象添加新键
// Object.preventExtensions(arr)
//判断是否可添加新键 返回bool
// console.log(Object.isExtensible(arr))

//封闭对象、设置对象无法添加、删除内容
// Object.seal(arr)
//判断是否封闭对象 返回bool
// console.log(Object.isSealed(arr))

//冻结对象、设置对象内属性无法被删除、修改、添加
// Object.freeze(arr)
//判断是否冻结对象 返回bool
// console.log(Object.isFrozen(arr))
arr.name = 'jack'
arr.age = 11
arr.job = 'web'
delete arr.name
console.log(arr)
```

------

#### 遍历：

```javascript
//对象
let list = {
	name: 'adic',
	age: 18,
	birth: '1999',
	first: 'david'
}
//将list键key的长度作为循环条件，将键传入函数内部
for(const key in list){
	console.log(key)
}

//数组
let arr = ['java','js','c#','vue','css']
//将arr的长度作为循环条件，将arr的下标传入函数内部,如果将 in 替换为 of，则将arr下标对应的内容传入函数内部
for(const index in arr){
	console.log(index)
}
```

### 浅拷贝、深拷贝

#### 一.浅拷贝

```javascript
let list = {
	name: 'adic',
	age: 18,
	birth: '1999',
	first: 'david'
}
// 1.对象合并
// let new_list = Object.assign({},list)

// 2.对象遍历
// let new_list = {}
// for(const key in list){
// 	new_list[key] = list[key]
// }

// 3.展开赋值
// let new_list = {...list}
new_list.name = 'bob'
console.log(list)
```

#### 二.深拷贝

```javascript
let list = {
	name: 'adic',
	job: {
		name: 'web',
		cate: 'comput'
	},
	arr: ['艾拉']
}
function deepCopy(obj) {
	//类型检查与定义
	let res = obj instanceof Array ? [] : {},
	//循环遍历 使用entries()将对象拆分为键值对应的数组，使用数组展开讲内容转换为两个单项k v
	for (const [k, v] of Object.entries(obj)) {
		//判断类型并且赋值结果
		res[k] = typeof v == 'object' ? deepCopy(v) : v
	}
	return res
}
let new_list = deepCopy(list)
new_list.job.name = 'css'
new_list.arr[0] = '艾利欧'
console.log(list)
console.log(new_list)
```

------

### 其他

#### 一.访问器

```javascript
//访问器的优先级高于普通属性
let arr = {
	data: {age: 18,name: 'adic'},
	set age(val){
		console.log(val,'set')
		this.data.age = val
	},
	get total(){
		console.log('get')
		return this.data.age	
	}
}
// arr.total = '17'//无法在外部改变对象内的访问器
console.log(arr)
```

